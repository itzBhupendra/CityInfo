using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using LogDashboardApi.Models;

namespace LogDashboardApi.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class LogsController : ControllerBase
    {
        private readonly ILogger<LogsController> _logger;

        public LogsController(ILogger<LogsController> logger)
        {
            _logger = logger;
        }

        [HttpGet]
        public async Task<IActionResult> Get(string correlationId, string basePath)
        {
            if (string.IsNullOrEmpty(correlationId))
            {
                return BadRequest("CorrelationId is required.");
            }

            if (string.IsNullOrEmpty(basePath) || !Directory.Exists(basePath))
            {
                return BadRequest("Valid base path is required.");
            }

            var logResults = new List<LogResult>();

            try
            {
                var logFiles = GetAllLogFiles(basePath);
                foreach (var logFile in logFiles)
                {
                    var lines = await System.IO.File.ReadAllLinesAsync(logFile);
                    logResults.AddRange(ParseLogLines(lines, correlationId));
                }

                return Ok(logResults);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error reading log files.");
                return StatusCode(500, "Internal server error");
            }
        }

        private IEnumerable<string> GetAllLogFiles(string basePath)
        {
            var logFiles = new List<string>();
            var directories = Directory.GetDirectories(basePath);

            foreach (var directory in directories)
            {
                logFiles.AddRange(GetAllLogFiles(directory));
            }

            logFiles.AddRange(Directory.GetFiles(basePath, "*.txt"));

            return logFiles;
        }

        private IEnumerable<LogResult> ParseLogLines(string[] lines, string correlationId)
        {
            var logResults = new List<LogResult>();
            LogResult currentLogEntry = null;
            var messageBuilder = new List<string>();

            foreach (var line in lines)
            {
                if (IsNewLogEntry(line))
                {
                    // Add the previous log entry to the results if it matches the correlationId
                    if (currentLogEntry != null && currentLogEntry.CorrelationId == correlationId)
                    {
                        currentLogEntry.Message = string.Join(Environment.NewLine, messageBuilder);
                        logResults.Add(currentLogEntry);
                    }

                    // Start a new log entry
                    currentLogEntry = ParseLogHeader(line);
                    messageBuilder.Clear();
                    if (currentLogEntry != null)
                    {
                        messageBuilder.Add(currentLogEntry.Message);
                        currentLogEntry.Message = null; // Clear the message since it is already added to the builder
                    }
                }
                else if (currentLogEntry != null)
                {
                    // Continue appending lines to the current log entry's message
                    messageBuilder.Add(line);
                }
            }

            // Add the last log entry to the results if it matches the correlationId
            if (currentLogEntry != null && currentLogEntry.CorrelationId == correlationId)
            {
                currentLogEntry.Message = string.Join(Environment.NewLine, messageBuilder);
                logResults.Add(currentLogEntry);
            }

            return logResults;
        }

        private bool IsNewLogEntry(string line)
        {
            // Assuming log entries start with a date in the format: [DateTime]
            return Regex.IsMatch(line, @"^\[\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\]");
        }

        private LogResult ParseLogHeader(string line)
        {
            try
            {
                var match = Regex.Match(line, @"^\[(?<dateTime>.+?)\] \[(?<logLevel>.+?)\] \[(?<correlationId>.+?)\] (?<message>.+)$");
                if (match.Success)
                {
                    return new LogResult
                    {
                        DateTime = DateTime.Parse(match.Groups["dateTime"].Value),
                        LogLevel = match.Groups["logLevel"].Value,
                        CorrelationId = match.Groups["correlationId"].Value,
                        Message = match.Groups["message"].Value // Initial part of the message
                    };
                }
            }
            catch
            {
                // Ignore parsing errors and return null
            }

            return null;
        }
    }
}
