using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Threading.Tasks;
using System.Windows;

public class MainViewModel : INotifyPropertyChanged
{
    public ObservableCollection<LogEntry> Logs { get; set; } = new ObservableCollection<LogEntry>();

    private bool _isLoading;
    public bool IsLoading
    {
        get => _isLoading;
        set
        {
            _isLoading = value;
            OnPropertyChanged(nameof(IsLoading));
        }
    }

    public RelayCommand FetchLogsCommand { get; }

    public MainViewModel()
    {
        FetchLogsCommand = new RelayCommand(async _ => await FetchLogsAsync(), _ => !IsLoading);
    }

    private async Task FetchLogsAsync()
    {
        IsLoading = true;

        try
        {
            // Perform the API call in a background thread
            var logs = await Task.Run(() =>
            {
                // Simulate fetching logs from API
                return ApiService.FetchLogs("your-correlation-id");
            });

            // Update the UI thread with fetched data
            Application.Current.Dispatcher.Invoke(() =>
            {
                Logs.Clear();
                foreach (var log in logs)
                {
                    Logs.Add(log);
                }
            });
        }
        catch (Exception ex)
        {
            MessageBox.Show($"An error occurred: {ex.Message}");
        }
        finally
        {
            IsLoading = false;
        }
    }

    public event PropertyChangedEventHandler PropertyChanged;
    protected void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
