using System;
using System.Windows.Input;

public class RelayCommand : ICommand
{
    private readonly Action _execute;
    private readonly Func<bool> _canExecute;

    public RelayCommand(Action execute)
        : this(execute, null)
    {
    }

    public RelayCommand(Action execute, Func<bool> canExecute)
    {
        _execute = execute ?? throw new ArgumentNullException(nameof(execute));
        _canExecute = canExecute;
    }

    public event EventHandler CanExecuteChanged
    {
        add => CommandManager.RequerySuggested += value;
        remove => CommandManager.RequerySuggested -= value;
    }

    public bool CanExecute(object parameter)
    {
        return _canExecute == null || _canExecute();
    }

    public void Execute(object parameter)
    {
        _execute();
    }
}


using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;
using System.Windows.Data;
using System.Windows.Input;

namespace LogViewer.ViewModels
{
    public class MainViewModel : INotifyPropertyChanged
    {
        private string _filterText;
        private ObservableCollection<LogEntry> _logs;
        private ICollectionView _filteredLogs;

        public MainViewModel()
        {
            // Sample data
            Logs = new ObservableCollection<LogEntry>
            {
                new LogEntry { DateTime = "2024-06-10T03:56:22.572", LogLevel = "Error", CorrelationId = "ABC123", Message = "SYSTEM_EXCEPTION: Something went wrong", LogFolderName = "API1" },
                new LogEntry { DateTime = "2024-06-10T04:56:22.572", LogLevel = "Info", CorrelationId = "DEF456", Message = "Operation completed", LogFolderName = "API2" }
            };

            // Initialize filtered collection
            FilteredLogs = CollectionViewSource.GetDefaultView(Logs);
            FilteredLogs.Filter = FilterLogs;
        }

        public ObservableCollection<LogEntry> Logs
        {
            get => _logs;
            set
            {
                _logs = value;
                OnPropertyChanged(nameof(Logs));
                FilteredLogs.Refresh();  // Refresh when the original list changes
            }
        }

        public ICollectionView FilteredLogs
        {
            get => _filteredLogs;
            set
            {
                _filteredLogs = value;
                OnPropertyChanged(nameof(FilteredLogs));
            }
        }

        public string FilterText
        {
            get => _filterText;
            set
            {
                if (_filterText != value)
                {
                    _filterText = value;
                    OnPropertyChanged(nameof(FilterText));
                    FilteredLogs.Refresh();  // Refresh collection when filter changes
                }
            }
        }

        private bool FilterLogs(object obj)
        {
            if (obj is LogEntry logEntry)
            {
                // Filter based on correlation ID and if message starts with "SYSTEM_EXCEPTION"
                return string.IsNullOrEmpty(FilterText) || logEntry.CorrelationId.Contains(FilterText) && logEntry.Message.StartsWith("SYSTEM_EXCEPTION");
            }
            return false;
        }

        // Fix here: use a lambda to wrap the FetchLogs method
        public ICommand FetchLogsCommand => new RelayCommand((param) => FetchLogs());

        private void FetchLogs()
        {
            // Call API to fetch logs here
        }

        public event PropertyChangedEventHandler PropertyChanged;
        private void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }

    public class LogEntry
    {
        public string DateTime { get; set; }
        public string LogLevel { get; set; }
        public string CorrelationId { get; set; }
        public string Message { get; set; }
        public string LogFolderName { get; set; }
    }
}
