using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using LogDashboardApi.Models;

namespace LogDashboardApi.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class LogsController : ControllerBase
    {
        private readonly ILogger<LogsController> _logger;

        public LogsController(ILogger<LogsController> logger)
        {
            _logger = logger;
        }

        [HttpGet("{correlationId}")]
        public async Task<IActionResult> Get(string correlationId, [FromQuery] string basePath)
        {
            if (string.IsNullOrEmpty(correlationId))
            {
                return BadRequest("CorrelationId is required.");
            }

            if (string.IsNullOrEmpty(basePath) || !Directory.Exists(basePath))
            {
                return BadRequest("Valid base path is required.");
            }

            var logResults = new List<LogResult>();

            try
            {
                var logFiles = GetAllLogFiles(basePath);
                foreach (var logFile in logFiles)
                {
                    var lines = await System.IO.File.ReadAllLinesAsync(logFile);
                    var folderName = new DirectoryInfo(Path.GetDirectoryName(logFile)).Name;
                    logResults.AddRange(ParseLogLines(lines, correlationId, folderName));
                }

                return Ok(logResults);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error reading log files.");
                return StatusCode(500, "Internal server error");
            }
        }

        private IEnumerable<string> GetAllLogFiles(string basePath)
        {
            var logFiles = new List<string>();
            var directories = Directory.GetDirectories(basePath);

            foreach (var directory in directories)
            {
                logFiles.AddRange(GetAllLogFiles(directory));
            }

            logFiles.AddRange(Directory.GetFiles(basePath, "*.txt"));

            return logFiles;
        }

        private IEnumerable<LogResult> ParseLogLines(string[] lines, string correlationId, string folderName)
        {
            var logResults = new List<LogResult>();
            LogResult currentLogEntry = null;
            var messageBuilder = new List<string>();

            foreach (var line in lines)
            {
                if (IsNewLogEntry(line))
                {
                    if (currentLogEntry != null && currentLogEntry.CorrelationId == correlationId)
                    {
                        currentLogEntry.Message = string.Join(Environment.NewLine, messageBuilder);
                        logResults.Add(currentLogEntry);
                    }

                    currentLogEntry = ParseLogHeader(line, folderName);
                    messageBuilder.Clear();
                    if (currentLogEntry != null)
                    {
                        messageBuilder.Add(currentLogEntry.Message);
                        currentLogEntry.Message = null;
                    }
                }
                else if (currentLogEntry != null)
                {
                    messageBuilder.Add(line);
                }
            }

            if (currentLogEntry != null && currentLogEntry.CorrelationId == correlationId)
            {
                currentLogEntry.Message = string.Join(Environment.NewLine, messageBuilder);
                logResults.Add(currentLogEntry);
            }

            return logResults;
        }

        private bool IsNewLogEntry(string line)
        {
            return Regex.IsMatch(line, @"^\[\d{2}/\d{2}/\d{4} \d{2}:\d{2}:\d{2}\.\d{3}\]");
        }

        private LogResult ParseLogHeader(string line, string folderName)
        {
            try
            {
                var match = Regex.Match(line, @"^\[(?<dateTime>\d{2}/\d{2}/\d{4} \d{2}:\d{2}:\d{2}\.\d{3})\] \[(?<logLevel>.+?)\] \[(?<correlationId>[0-9a-fA-F-]{36})\] : (?<message>.+)$");
                if (match.Success)
                {
                    return new LogResult
                    {
                        DateTime = DateTime.ParseExact(match.Groups["dateTime"].Value, "MM/dd/yyyy HH:mm:ss.fff", null),
                        LogLevel = match.Groups["logLevel"].Value,
                        CorrelationId = match.Groups["correlationId"].Value,
                        Message = match.Groups["message"].Value,
                        LogFolderName = folderName  // Include the folder name
                    };
                }
            }
            catch
            {
                // Ignore parsing errors and return null
            }

            return null;
        }
    }
}
